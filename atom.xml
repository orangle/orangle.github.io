<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Orangleliu Notes]]></title>
  <subtitle><![CDATA[爱生活，Linux，Python，和媳妇]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://orangleliu.info/"/>
  <updated>2015-11-04T12:25:11.000Z</updated>
  <id>http://orangleliu.info/</id>
  
  <author>
    <name><![CDATA[orangleliu]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[django-orm中F对象的使用]]></title>
    <link href="http://orangleliu.info/2015/11/04/django-orm-use-F-class/"/>
    <id>http://orangleliu.info/2015/11/04/django-orm-use-F-class/</id>
    <published>2015-11-04T12:18:12.000Z</published>
    <updated>2015-11-04T12:25:11.000Z</updated>
    <content type="html"><![CDATA[ <a id="more"></a>
<h2 id="前言">前言</h2><p>django文档中有一节是 <a href="https://docs.djangoproject.com/en/1.7/ref/models/queries/#prefetch-objects" target="_blank" rel="external">Query-related classes</a>,说<br>的是关联查询，1.7新加上去的，这里的关联是字段的关联，而不是表之间的关联。</p>
<p>表关联中主要用的是3个对象 F(), Q(), 和Prefetch()，其中Prefetch是1.7新加入的，其他两个是之前版本就有的。之前有个需求是比较一张表里的两个时间字段，<a href="http://blog.csdn.net/orangleliu/article/details/22273003" target="_blank" rel="external">用到过F这个对象</a>，今天再看djangocon的ppt时候又发现了一些新的用法，于是查询了下文档，小结一下。</p>
<h2 id="概念">概念</h2><blockquote>
<p>class F<br><br>F()是代表模型字段的值，也就是说对于一些特殊的字段的操作，我们不需要用python把数据先取到内存中，然后操作，在存储到db中了。</p>
</blockquote>
<h2 id="场景">场景</h2><p>几个常用的情景</p>
<h3 id="字段+1(加减乘除运算)"><a href="https://docs.djangoproject.com/en/1.7/ref/models/queries/#f-expressions" target="_blank" rel="external">字段+1(加减乘除运算)</a></h3><p>例如我们有个统计点击量的字段，每次更新的操作其实就是把字段的值加1.</p>
<p>一般我们的做法是把这条记录取出来，把相应字段加+1，然后在save，类似下面的代码：</p>
<pre><code><span class="comment"># Tintin filed a news story!</span>
reporter = Reporters.objects.<span class="keyword">get</span>(<span class="property">name</span>='Tintin')
reporter.stories_filed += <span class="number">1</span>
reporter.save()
</code></pre><p>当我们使用了F()之后呢？ 只需要一行代码</p>
<pre><code>Reporters<span class="class">.objects</span><span class="class">.filter</span>(name=<span class="string">'Tintin'</span>).<span class="function"><span class="title">update</span><span class="params">(stories_filed=F(<span class="string">'stories_filed'</span>)</span></span> + <span class="number">1</span>)
</code></pre><p>不仅代码量少了，而且这是直接在数据中操作，效率也变高了，特别是并发的情况，减少了多线程同时操作带来的隐患。<br><strong>但是不支持字符串相加的操作</strong></p>
<h3 id="字段比较"><a href="https://docs.djangoproject.com/en/1.7/topics/db/queries/#using-f-expressions-in-filters" target="_blank" rel="external">字段比较</a></h3><p>例如一个合同有两个日期，一个叫做终止日期，一个叫做结束日期，现在要筛选出终止日期小于结束日期的合同。</p>
<pre><code>from django<span class="class">.db</span><span class="class">.models</span> import F
from contracts<span class="class">.models</span> import Contracts
contracts = Contracts<span class="class">.objects</span><span class="class">.filter</span>(contract_stop_time__lt=<span class="function"><span class="title">F</span><span class="params">(<span class="string">'end_time'</span>)</span></span>)
</code></pre><p>如果没有F对象，就没法直接使用rom来查询。</p>
<h2 id="小结">小结</h2><p>现在时发现这两类用法，如果还有新的用法或者拓展，在更新。</p>
]]></content>
    <summary type="html">
    <![CDATA[ <a id="more"></a>
<h2 id="前言">前言</h2><p>django文档中有一节是 <a href="https://docs.djangoproject.com/en/1.7/ref/models/queries/#prefetch-objects" ]]>
    </summary>
    
      <category term="orm" scheme="http://orangleliu.info/tags/orm/"/>
    
      <category term="django" scheme="http://orangleliu.info/categories/django/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Django中建立数据库视图]]></title>
    <link href="http://orangleliu.info/2015/11/04/Django-create-data-view/"/>
    <id>http://orangleliu.info/2015/11/04/Django-create-data-view/</id>
    <published>2015-11-04T12:17:29.000Z</published>
    <updated>2015-11-04T12:23:41.000Z</updated>
    <content type="html"><![CDATA[ <a id="more"></a>
<blockquote>
<p>Django中没有建立视图的接口，如果要建立一个视图需要一些手动的改变。<br>这里使用的Django 版本&gt;1.5， 使用的数据库为mysql</p>
</blockquote>
<h3 id="第一步">第一步</h3><p>建立视图,例如视图的名称叫做 user_info</p>
<h3 id="第二步">第二步</h3><p>model中这么写：</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">MyModel</span><span class="params">(models.Model)</span>:</span>
    ...
    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span>
         managed = <span class="keyword">False</span>
         db_table = <span class="string">"user_info"</span>
</code></pre><p>这样就可以把视图经过orm变成对象了。</p>
<h3 id="REF:">REF:</h3><p><a href="http://stackoverflow.com/questions/2245956/creating-django-model-for-existing-database-sql-view" target="_blank" rel="external">creating django model for existing database/sql view?</a></p>
<p><a href="https://docs.djangoproject.com/en/dev/ref/models/options/#django.db.models.Options.managed" target="_blank" rel="external">Django models文档</a></p>
]]></content>
    <summary type="html">
    <![CDATA[ <a id="more"></a>
<blockquote>
<p>Django中没有建立视图的接口，如果要建立一个视图需要一些手动的改变。<br>这里使用的Django 版本&gt;1.5， 使用的数据库为mysql</p>
</blockquote>
<h3 id="第一步]]>
    </summary>
    
      <category term="orm" scheme="http://orangleliu.info/tags/orm/"/>
    
      <category term="django" scheme="http://orangleliu.info/categories/django/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hexo 博客使用记]]></title>
    <link href="http://orangleliu.info/2015/11/04/hexo-blog-notes/"/>
    <id>http://orangleliu.info/2015/11/04/hexo-blog-notes/</id>
    <published>2015-11-04T07:25:04.000Z</published>
    <updated>2015-11-04T11:58:05.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>Github Pages用了大概一年多，之前的都是基于jekll的，但是比较烂，加上弄得主题不好看，也就没怎么写文章了，这两日看到以前的伙伴弄了个hexo主题的静态博客，于是也来尝尝鲜，学习学习。</p>
</blockquote>
<h3 id="TODO">TODO</h3><ul>
<li>评论测试</li>
<li>统计测试</li>
<li>增加一个第三方统计</li>
<li>文章迁移</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>Github Pages用了大概一年多，之前的都是基于jekll的，但是比较烂，加上弄得主题不好看，也就没怎么写文章了，这两日看到以前的伙伴弄了个hexo主题的静态博客，于是也来尝尝鲜，学习学习。</p>
</blockquote>
<h3 id=]]>
    </summary>
    
      <category term="hexo" scheme="http://orangleliu.info/tags/hexo/"/>
    
      <category term="折腾" scheme="http://orangleliu.info/categories/%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[lzz的编程之旅2015-Pycon]]></title>
    <link href="http://orangleliu.info/2015/10/14/lzz-programe-travel-20153/"/>
    <id>http://orangleliu.info/2015/10/14/lzz-programe-travel-20153/</id>
    <published>2015-10-14T10:17:48.000Z</published>
    <updated>2015-11-04T12:01:11.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Pycon">Pycon</h2><p>今年的PyCon算是赶上了, 9月19日是个晴朗的周六，北京的python爱好者们在77剧场相聚，愉快的完成了15年的大聚会。总得来说今年要比去年进步很多的（虽然去年我没参加^^）, 下面是一个大合影。</p>
<p><img src="/img/pycon2015.jpg" alt="pycon2015"></p>
<h2 id="最近csdn的经历">最近csdn的经历</h2><p>CSDN最近开始主推一个叫做<code>极客头条</code>的板块，在他们的专家群里响应号召，加入了核心分享小分队。如果你经常看<code>Hacknews</code>应该对这种风格的事物不陌生，如果你关注过<code>开发者，伯乐，稀土。。头条</code>，应该非常熟悉这种模式了。就是个大家分享好文章的地方，只发链接，通过大家的推荐自动聚合一些技术干货文章，业界新闻。</p>
<p>参与分享，也参与阅读。就自己感觉来说，I 分享的大部分内容对自己来说还是比较有益处的，看了之后多少都有些过收获。文章的来源无非下面几种， 一个是研究问题时候看到的，一些是订阅博客之类看到的，还有一些就是别人分享给我的，然后觉得很好在分享给大家。2个多月分享了大概快100篇，大部分都是无人问津，少部分浅显的文章得到的赞最多（一般都是高大上的标题加上一些货真价实的确实有些初级的有用的内容）。效果最差的应该就是英文文章，大部分都是没人看，还有很多得到了<code>踩</code>的荣誉，从个人的角度来看，真的是非常好的文章。从这些迹象来看吧，大部分还是比较肤浅的，有的时候可能根本仔细看内容，人云亦云的点个赞，还有不愿意读英文文章也是个坏习惯。</p>
<p>再说说作为一个读者的感受。从文章的热度来看，前端，移动端，java，还有各种人生指导（各种10年，15年，一个优秀程序员的各种xx）是最受欢迎的。相反一些需要查阅资料，<code>认真理解</code>才能看的懂得文章并不受到待见。开始的时候还有一些英文分享，后来基本都见不到了，估计是总是<code>减积分</code>没人愿意做这种事了，有点可惜。</p>
<p>所以很容易就明白，为啥靠谱的程序员也不多了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Pycon">Pycon</h2><p>今年的PyCon算是赶上了, 9月19日是个晴朗的周六，北京的python爱好者们在77剧场相聚，愉快的完成了15年的大聚会。总得来说今年要比去年进步很多的（虽然去年我没参加^^）, 下面是一个大合影。</p>
<p><i]]>
    </summary>
    
      <category term="随想" scheme="http://orangleliu.info/tags/%E9%9A%8F%E6%83%B3/"/>
    
      <category term="生活" scheme="http://orangleliu.info/categories/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[lzz的编程之旅2015-2]]></title>
    <link href="http://orangleliu.info/2015/09/01/lzz-programe-travel-20152/"/>
    <id>http://orangleliu.info/2015/09/01/lzz-programe-travel-20152/</id>
    <published>2015-09-01T10:17:48.000Z</published>
    <updated>2015-11-04T11:59:53.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>不知不觉已经到郭哥的公司一年了，和大家相处的很好，感觉非常温暖（好像呆过的其他公司一样，不管工作辛苦不辛苦，大家相处的非常融洽，即使不在一起工作也会经常联系，也许这就是程序员们的简单吧）。 也有点小抱怨，工资没有涨，平时也不发点小福利，好像把这些都忘了呀。。</p>
</blockquote>
<h2 id="回顾">回顾</h2><p>14年10月的时候从CC离职来到了<code>尔雅</code>，当时应该是12个人，现在是16个人，走了一个，来一个又走了，来了一个股东，还有其他4个人兄弟。 还是比原来有所壮大，14年到15年初的这段时间，谈了很多合作的苗头，花了很多时间来做demo，大部分的结果就是不了了之，这些项目对于我们来说可能是<code>救命草</code>，可是对于它们来说就是个幌子或者一个临时的想法。后来就吸取了教训，该放弃就要放弃，毕竟经历有限，对于不太靠谱的公司和人，尽早远离。</p>
<p>15年第二个季度算是开始有起色，不管是新疆校园，还是北京wifi的项目，总算是有些像样的事情在做了，虽然现在看后面非常艰苦，但是我想我们一定会一起好好的走下去。</p>
<p><code>9.30</code> 进行了这一年的第一次团建，从<code>那达慕大会</code>到<code>十渡</code>，各种讨论最后还是进行了一次<code>重装野营</code>，目的地是<code>后河</code>。对于我们大部分人来说这是人生第一次野营，整个团队一起出去呆了2天一夜，没有手机信号，只有溪流声，山谷，和绿色，虽然非常累，但是感觉非常好。中间经历了一次山谷暴雨，有几个帐篷都进水了，哈哈，呆在帐篷里面害怕被吹翻的感觉真奇怪。</p>
<p><img src="/img/2015tuanjian.jpg" alt="团建2015"></p>
<h2 id="工作思考">工作思考</h2><p>对于上班制度说，自由度是非常高的，只要事情做好就行，不提倡加班。总是一段时间忙，一段时间比较空闲。</p>
<p>但是新疆这个项目，还是发现了很多之前不太关注的问题。以前总是想做，但是没做的事，导致了后来非常被动。一个是代码和部署的问题，一个是本地环境和线上环境切换的问题，还有一个就是缺乏运维经验的问题。小公司这些问题如果自己不去解决，是没人来规范的，因为总有各种事情占满时间，想要把这个趋势往好的方向带的确需要很大的决心啊。希望自己在以后这段时间能把整个事情整得有条理些，不然越来越臃肿，最后每次上线都要心惊胆战呀。</p>
<p>在这边的工作内容比较复杂，测试要自己做，运维的工作我也要兼职（因为用linux的时间还算长，虽然没专业做过运维，不过学起来还算快），还有部分开发的工作。 虽然乱七八糟吧，确实也学到了很多东西。</p>
<h2 id="未来">未来</h2><p>希望15年我们能有大得起色，然后自己不光能再技术上提高，更要在团队建设和开发流程，问题解决上能积累有效的经验。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>不知不觉已经到郭哥的公司一年了，和大家相处的很好，感觉非常温暖（好像呆过的其他公司一样，不管工作辛苦不辛苦，大家相处的非常融洽，即使不在一起工作也会经常联系，也许这就是程序员们的简单吧）。 也有点小抱怨，工资没有涨，平时也不发点小福利，好像把这些都]]>
    </summary>
    
      <category term="随想" scheme="http://orangleliu.info/tags/%E9%9A%8F%E6%83%B3/"/>
    
      <category term="生活" scheme="http://orangleliu.info/categories/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[lzz的编程之旅2015-1]]></title>
    <link href="http://orangleliu.info/2015/06/24/lzz-programe-travel-20151/"/>
    <id>http://orangleliu.info/2015/06/24/lzz-programe-travel-20151/</id>
    <published>2015-06-24T10:17:48.000Z</published>
    <updated>2015-11-04T11:57:50.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>想来时间过得也快，2012年7月2日第一天上班到现在也快3年了，从大学的时候不知道做什么到后来干软件，到现在也算是 <code>干一行爱一行</code> 吧，至少现在是挺热爱的。记得上学的时候总觉得自己也能写几个文字，弄弄笔墨，到这两年发现写个句子都有点不连贯了。那么以后还是要耍耍键盘，写写自己的生活体会，也好给未来的自己瞅一瞅。</p>
</blockquote>
<h3 id="工作">工作</h3><p>这话题是关乎于钱的，说的好听一点就是事业，对于我这么一个打工仔就是给谁打工，以及打工内容的问题。从毕业起就对自己说”赚钱不是当务之急，努力学习工作经验，增加技能才是最重要的”，所以对于工资低一些的岗位也干的挺卖力，到了后来才发现，其实我也没有学到啥，对自我的评价还是刚刚入门。</p>
<h3 id="从前">从前</h3><p>大学的时候那个专业叫做 <code>电子信息工程</code>，一所二本师范类学校，加上自己也不知道想干嘛，所以四年虽说没有完全荒废，但也可以说毫无建树，加上自己本来就有些<code>内向</code>的性格。其实到了社会上，真的不如<code>自认为没有自己聪明</code>的那些同学。虽然父母从高中就开始警告我这个问题，总得来说改观不是特别大，革命尚未成功，努力趁现在。</p>
<p>因为本来并不是计算机专业，专业基础上还是会差一些，所以上班期间总是提醒自己，不能跟风学习花哨的技术，牢固的基础才是保证啊。补上了一些，还是漏掉了一些，太枯燥的东西，学习起来总是没法坚持很长久，所以现在买书少了，因为看完的百分比的确不是很大。</p>
<h3 id="现在">现在</h3><p>这段时间来看，学习的时间确实少了很多，学习的深度依旧不是那么深，乱七八糟看的太多，认认真真研究透彻的少，这个是之后一段时间需要改变的态度。好奇心到时有，但是好奇的时间有点短，转移注意力的能力有点强，总是刚刚把手放到一个知识的表面，就又把视线转到另外一个新奇的东西上了。</p>
<p>有一个体会是很深的，一个人经验再多，总有他不清楚的地方。所以一定要谦逊，不能有丝毫的架子，在对待一个你觉得可能某些方面不如自己的人，事实上可能是自己的眼睛没有看清。</p>
<p>现在是我的第三份工作，是一个创业公司，即使没有刚开始那么看到我也会尽可能的待的长久一些。在这里我有了很多自己可以掌控的技术的，项目的东西，发现自己知道的东西还很少，需要从头开始研究的东西很多，即使开始有些迷茫，我想这后来的时间我会给自己一些鼓励和更多的要求，做出来自己觉得满意的东西。</p>
<p>以后的一段时间，多花时间读书，多陪小妞，多想想以前不愿意想的东西，都咀嚼下从前做过的东西，坚持的自己的坚持，好好的走下去。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>想来时间过得也快，2012年7月2日第一天上班到现在也快3年了，从大学的时候不知道做什么到后来干软件，到现在也算是 <code>干一行爱一行</code> 吧，至少现在是挺热爱的。记得上学的时候总觉得自己也能写几个文字，弄弄笔墨，到这两年发现写个句]]>
    </summary>
    
      <category term="随想" scheme="http://orangleliu.info/tags/%E9%9A%8F%E6%83%B3/"/>
    
      <category term="生活" scheme="http://orangleliu.info/categories/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[mysql主从数据不一致问题解决过程]]></title>
    <link href="http://orangleliu.info/2015/06/17/mysql-slave-data-not-same/"/>
    <id>http://orangleliu.info/2015/06/17/mysql-slave-data-not-same/</id>
    <published>2015-06-17T09:49:30.000Z</published>
    <updated>2015-11-04T12:03:31.000Z</updated>
    <content type="html"><![CDATA[ <a id="more"></a>
<blockquote>
<p>情况时这样的<br>昨天晚上主动2个机器都迁移了，然后今天才把主动重新连接上，但是从库的偏移量是从今天当前时刻开始的，也就是说虽然现在主动看似正常，其实是少了昨天的部分数据，由于从库的数据丢失了，早晚还是要填坑的。</p>
</blockquote>
<h2 id="问题">问题</h2><ul>
<li>要解决问题就是怎么对比不一致，然后在不影响业务的情况下，修复数据不一致的问题，把从库缺少的数据补上</li>
</ul>
<p>下面是能想到和找到的几个方案</p>
<ol>
<li>从新从0开始同步，虽然对主库的使用没有影响，但是那么大的数据量，对性能，网络影响有点大，数据丢失的应该很少</li>
<li>主库dump数据，锁库，然后同步，不好。 影响业务使用</li>
<li>percona-toolkit 中的工具来校验和同步，从介绍上来看是符合现在的情况的，使用上还需要学习和认识才行。</li>
</ol>
<p>下面是几个参考链接</p>
<ul>
<li><a href="https://www.percona.com/software/percona-toolkit" target="_blank" rel="external">percona-toolkit工具</a> 官方地址</li>
<li><a href="http://huoding.com/2013/05/03/251" target="_blank" rel="external">MySQL主从服务器数据一致性的核对与修复</a>  简单描述下过程</li>
<li><a href="http://nettedfish.sinaapp.com/blog/2013/06/04/check-replication-consistency-by-pt-table-checksum/" target="_blank" rel="external">用pt-table-checksum校验数据一致性</a>  描述工具原理</li>
<li><a href="http://nettedfish.sinaapp.com/blog/2013/06/05/synchronizes-data-efficiently-by-pt-table-sync/" target="_blank" rel="external">用pt-table-sync修复不一致的数据</a> 描述了工具原理</li>
</ul>
<h2 id="操作过程">操作过程</h2><p>只把过程和用到的东西解释了下，有些参数选项等还需要查阅文档。两台机器都是centos6.5 mysql版本都是5.6 , 由于是线上环境，这里ip和密码等敏感信息修改了下。</p>
<ul>
<li>主   192.168.1.100</li>
<li>从   192.168.1.98</li>
<li>修复数据库名   radius</li>
</ul>
<h3 id="工具安装">工具安装</h3><p>在<code>主库服务器</code>安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装依赖包</span></span><br><span class="line">yum install perl-DBI  perl-DBD-MySQL  perl-TermReadKey perl-Time-HiRes</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装工具</span></span><br><span class="line">wget percona.com/get/percona-toolkit.tar.gz</span><br><span class="line">tar zxvf percona-toolkit-<span class="number">2.2</span>.<span class="number">14</span>.tar.gz</span><br><span class="line"><span class="built_in">cd</span> percona-toolkit-<span class="number">2.2</span>.<span class="number">14</span></span><br><span class="line">perl Makefile.PL &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<h3 id="校验数据一致性">校验数据一致性</h3><h4 id="建立用户并授权">建立用户并授权</h4><p>注意这里要在主从创建一个同名的用户，可以从主库访问从库，主库本地可以访问主库。工具的使用都是在主库的服务器上进行,使用<br>pt-table-checksum校验数据一致性。</p>
<p>从库mysql操作</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>,PROCESS, SUPER, <span class="keyword">REPLICATION</span> <span class="keyword">SLAVE</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'checksums'</span>@<span class="string">'192.168.1.100'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'slavecheck'</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="operator"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span></span><br></pre></td></tr></table></figure>
<p>​<br>主库mysql操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GRANT SELECT, PROCESS, SUPER, REPLICATION SLAVE ON *.* TO <span class="string">'checksums'</span>@<span class="string">'192.168.1.100'</span> IDENTIFIED BY <span class="string">'slavecheck'</span>;</span><br><span class="line"></span><br><span class="line">GRANT SELECT,INSERT,UPDATE,DELETE ON radius.checksums TO <span class="string">'checksums'</span>@<span class="string">'192.168.1.100'</span>;</span><br><span class="line"></span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<p>校验时候需要在主mysql 中新建一张表，新建用户需要有读写的权限，这里是把校验表建立在radius库中。</p>
<h4 id="pt-table-checksum_校验">pt-table-checksum 校验</h4><p>校验是在主库服务器上进行的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">主库shell中执行</span><br><span class="line">pt-table-checksum h=<span class="string">'192.168.1.100'</span>,u=<span class="string">'checksums'</span>,p=<span class="string">'slavecheck'</span>,P=<span class="number">3306</span> <span class="operator">-d</span> radius --nocheck-replication-filters --replicate=radius.checksums</span><br><span class="line"></span><br><span class="line">--nocheck-replication-filters ：不检查复制过滤器，建议启用。后面可以用--databases来指定需要检查的数据库。</span><br><span class="line">--no-check-binlog-format      : 不检查复制的binlog模式，要是binlog模式是ROW，则会报错。</span><br><span class="line">--replicate-check-only :只显示不同步的信息。</span><br><span class="line">--replicate=    ：把checksum的信息写入到指定表中，建议直接写到被检查的数据库当中。</span><br><span class="line">--databases=    ：指定需要被检查的数据库，多个则用逗号隔开。</span><br><span class="line">--tables=       ：指定需要被检查的表，多个用逗号隔开</span><br><span class="line">h=<span class="number">192.168</span>.<span class="number">1.100</span> ：Master的地址</span><br><span class="line">u=checksums         ：用户名</span><br><span class="line">p=slavecheck        ：密码</span><br><span class="line">P=<span class="number">3306</span>          ：端口</span><br></pre></td></tr></table></figure>
<p>这个脚本在主库机器上运行，会自动找到从库地址，并用相同的用户登录，然后对比。</p>
<p>–replicate 选项是建立一个表来存储对比信息，这个表一定要能同步到从库中，如果checksums用户没有建表权限，请自行建立好表</p>
<p>建表语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`radius`</span>.<span class="string">`checksums`</span> (</span><br><span class="line">     db             <span class="built_in">CHAR</span>(<span class="number">64</span>)     <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">     tbl            <span class="built_in">CHAR</span>(<span class="number">64</span>)     <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">     <span class="keyword">chunk</span>          <span class="built_in">INT</span>          <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">     chunk_time     <span class="built_in">FLOAT</span>            <span class="literal">NULL</span>,</span><br><span class="line">     chunk_index    <span class="built_in">VARCHAR</span>(<span class="number">200</span>)     <span class="literal">NULL</span>,</span><br><span class="line">     lower_boundary <span class="built_in">TEXT</span>             <span class="literal">NULL</span>,</span><br><span class="line">     upper_boundary <span class="built_in">TEXT</span>             <span class="literal">NULL</span>,</span><br><span class="line">     this_crc       <span class="built_in">CHAR</span>(<span class="number">40</span>)     <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">     this_cnt       <span class="built_in">INT</span>          <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">     master_crc     <span class="built_in">CHAR</span>(<span class="number">40</span>)         <span class="literal">NULL</span>,</span><br><span class="line">     master_cnt     <span class="built_in">INT</span>              <span class="literal">NULL</span>,</span><br><span class="line">     ts             <span class="keyword">TIMESTAMP</span>    <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">     PRIMARY <span class="keyword">KEY</span> (db, tbl, <span class="keyword">chunk</span>),</span><br><span class="line">     <span class="keyword">INDEX</span> ts_db_tbl (ts, db, tbl)</span><br><span class="line">  ) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span>;</span></span><br></pre></td></tr></table></figure>
<p>我这里手动建立好表之后出现了如下的错误</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span>-<span class="number">16</span>T16:<span class="number">10</span>:<span class="number">48</span> The <span class="comment">--replicate table `radius`.`checksums` exists on the master but but it has problems on these replicas:</span></span><br><span class="line">Table radius.checksums <span class="keyword">does</span> <span class="keyword">not</span> exist <span class="function_start"><span class="keyword">on</span></span> replica localhost.localdomain</span><br></pre></td></tr></table></figure>
<p>之前的错误，导致主从复制有问题，去从库查看主动状态，调整是得主从正常。</p>
<p>错误解决完了继续执行(结果有省略)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">下面继续在主库的shell上检查</span><br><span class="line">[root@localhost portal]<span class="comment"># pt-table-checksum h='192.168.1.100',u='checksums',p='slavecheck',P=3306 -d radius --nocheck-replication-filters --replicate=radius.checksums</span></span><br><span class="line">            TS ERRORS  DIFFS     ROWS  CHUNKS SKIPPED    TIME TABLE</span><br><span class="line"><span class="number">06</span>-<span class="number">16</span>T16:<span class="number">50</span>:<span class="number">21</span>      <span class="number">0</span>      <span class="number">1</span>     <span class="number">8379</span>       <span class="number">4</span>       <span class="number">0</span>   <span class="number">0.322</span> radius.account_account</span><br><span class="line"><span class="number">06</span>-<span class="number">16</span>T16:<span class="number">50</span>:<span class="number">21</span>      <span class="number">0</span>      <span class="number">1</span>    <span class="number">11429</span>       <span class="number">1</span>       <span class="number">0</span>   <span class="number">0.278</span> radius.account_mac</span><br><span class="line"><span class="number">06</span>-<span class="number">16</span>T16:<span class="number">50</span>:<span class="number">21</span>      <span class="number">0</span>      <span class="number">1</span>    <span class="number">63747</span>       <span class="number">1</span>       <span class="number">0</span>   <span class="number">0.329</span> radius.account_smslog</span><br><span class="line"><span class="number">06</span>-<span class="number">16</span>T16:<span class="number">50</span>:<span class="number">21</span>      <span class="number">0</span>      <span class="number">0</span>        <span class="number">0</span>       <span class="number">1</span>       <span class="number">0</span>   <span class="number">0.016</span> radius.auth_group</span><br><span class="line"><span class="number">06</span>-<span class="number">16</span>T16:<span class="number">50</span>:<span class="number">21</span>      <span class="number">0</span>      <span class="number">0</span>        <span class="number">0</span>       <span class="number">1</span>       <span class="number">0</span>   <span class="number">0.013</span> radius.auth_group_permissions</span><br><span class="line"><span class="number">06</span>-<span class="number">16</span>T16:<span class="number">50</span>:<span class="number">22</span>      <span class="number">0</span>      <span class="number">0</span>       <span class="number">27</span>       <span class="number">1</span>       <span class="number">0</span>   <span class="number">0.265</span> radius.auth_permission</span><br><span class="line"><span class="number">06</span>-<span class="number">16</span>T16:<span class="number">50</span>:<span class="number">22</span>      <span class="number">0</span>      <span class="number">1</span>     <span class="number">8384</span>       <span class="number">1</span>       <span class="number">0</span>   <span class="number">0.273</span> radius.auth_user</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>出现这种结果，说明已经check了，diffs一栏有不同，说明那些表数据不一致. 现在登录从库的mysql，执行如下语句</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from radius.checksums where master_cnt &lt;&gt; this_cnt OR master_crc &lt;&gt; this_crc OR ISNULL(master_crc) &lt;&gt; ISNULL(this_crc) \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">            db: radius</span><br><span class="line">           tbl: account_account</span><br><span class="line">         chunk: 2</span><br><span class="line">    chunk_time: 0.028065</span><br><span class="line">   chunk_index: PRIMARY</span><br><span class="line">lower_boundary: 1847</span><br><span class="line">upper_boundary: 9225</span><br><span class="line">      this_crc: 4f43a2</span><br><span class="line">      this_cnt: 7336</span><br><span class="line">    master_crc: 9235f7a2</span><br><span class="line">    master_cnt: 7379</span><br><span class="line">            ts: 2015-06-16 17:00:31</span><br></pre></td></tr></table></figure>
<p>一共有8条记录，这8张表数据不一致。 大概能看出来缺少了多少数据等。</p>
<h3 id="修复不一致数据">修复不一致数据</h3><p>修复不一致数据使用<code>pt-table-sync</code> 工具，使用<code>pt-table-checksum</code>工具的结果。不过这里还是有些坑。在修复之前最好把主mysql数据备份一下，因为会对主库有些写操作，有一点风险。</p>
<p>主库服务器执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost portal]<span class="comment"># pt-table-sync --execute --replicate radius.checksums --sync-to-master h="192.168.1.98",P=3306,u="checksums",p="slavecheck" --ignore-tables radacct,django_session</span></span><br><span class="line">DBI connect(<span class="string">';host=124.88.52.100;port=3306;mysql_read_default_group=client'</span>,<span class="string">'checksums'</span>,...) failed: Access denied <span class="keyword">for</span> user <span class="string">'checksums'</span>@<span class="string">'124.88.52.100'</span> (using password: YES) at /usr/<span class="built_in">local</span>/bin/pt-table-sync line <span class="number">2220</span></span><br><span class="line">但是直接用mysql连接就没问题</span><br></pre></td></tr></table></figure>
<p>最后查了下文档，发现还是用户权限的问题。<br>从库操作</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; GRANT all ON radius.* TO 'checksums'@'192.168.1.100';</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>主库操作</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; GRANT all ON radius.* TO 'checksums'@'192.168.1.100';</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>新增<code>增删改查</code>权限其实就够了 ,我这偷懒下。。</p>
<p>错误基本解决完了</p>
<h4 id="修复数据">修复数据</h4><p>先修复一个不重要的表来实验下(主库操作)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-table-sync --execute --replicate radius.checksums --sync-to-master h=<span class="number">192.168</span>.<span class="number">1.98</span>,P=<span class="number">3306</span>,u=checksums,p=<span class="string">"slavecheck"</span>  --tables account_smslog,radcheck --print</span><br></pre></td></tr></table></figure>
<p>修复完成在执行一次check 主库操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-table-checksum h=<span class="string">'192.168.1.100'</span>,u=<span class="string">'checksums'</span>,p=<span class="string">'slavecheck'</span>,P=<span class="number">3306</span> <span class="operator">-d</span> radius --nocheck-replication-filters --replicate=radius.checksums</span><br></pre></td></tr></table></figure>
<p>在从库mysql中检查下</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from radius.checksums where master_cnt &lt;&gt; this_cnt OR master_crc &lt;&gt; this_crc OR ISNULL(master_crc) &lt;&gt; ISNULL(this_crc) \G</span><br></pre></td></tr></table></figure>
<p>的确少了2张表，说明已经修复好了</p>
<p>接着把其他表修复，然后检查下是否有问题就OK了。</p>
<h2 id="小结">小结</h2><p>这里主要的问题就是</p>
<ol>
<li>脚本在那里执行（都是在主库服务器，从库只是检查下结果）</li>
<li>怎么建立用户，用户应该给予怎样的权限</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[ <a id="more"></a>
<blockquote>
<p>情况时这样的<br>昨天晚上主动2个机器都迁移了，然后今天才把主动重新连接上，但是从库的偏移量是从今天当前时刻开始的，也就是说虽然现在主动看似正常，其实是少了昨天的部分数据，由于从库的数据丢失了，早晚还是要填坑]]>
    </summary>
    
      <category term="mysql" scheme="http://orangleliu.info/tags/mysql/"/>
    
      <category term="数据库" scheme="http://orangleliu.info/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写个简单的Lua拓展-sleep函数]]></title>
    <link href="http://orangleliu.info/2015/03/23/write-simple-lua-c-extention/"/>
    <id>http://orangleliu.info/2015/03/23/write-simple-lua-c-extention/</id>
    <published>2015-03-23T12:17:48.000Z</published>
    <updated>2015-11-04T12:06:52.000Z</updated>
    <content type="html"><![CDATA[ <a id="more"></a>
<blockquote>
<p>这几天在做一个小项目，其中用到了一些基本的API, 例如sleep，获取当前目录等等，lua标准库中没有提供这些接口，虽然所第三方库中也都有实现，但是要用的就那么几个函数，在一个嵌入式系统中安装那么多第三方库有点浪费资源，于是<strong>@胜利哥</strong> 写了一个socket的C实现，然后给我用。我试着把其他几个函数也用C实现，首先看下怎么用C写lua的拓展。</p>
</blockquote>
<h3 id="C_部分">C 部分</h3><blockquote>
<p>首先是根据Lua C语言的协议写好调用模块，编译成.so 文件，然后才可以在lua脚本中调用。 下面是在<strong>Ubuntu14.04</strong>系统中，基于 lua5.1写的一个sleep实现。</p>
</blockquote>
<h4 id="sleep-c_文件">sleep.c 文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*学习写lua c拓展，对于一些简单的函数自己提供C拓展</span><br><span class="line"> *ubuntu 编译 $ gcc -fPIC -shared -llua sleep.c -o orangleliu.so -I/usr/include/lua5.1 -std=gnu99</span><br><span class="line"> */</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"unistd.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*这个三个是必须的头文件*/</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"lua.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"lualib.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"lauxlib.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*simple sleep*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sleep_c</span> <span class="params">(lua_State *L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> secs = lua_tointeger(L, -<span class="number">1</span>); <span class="comment">/*获取参数*/</span></span><br><span class="line">    sleep(secs);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                         <span class="comment">/*返回0个值，所以为0*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct</span> luaL_Reg libs[] = &#123;</span><br><span class="line">    &#123;<span class="string">"sleep"</span>, sleep_c&#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;  <span class="comment">/*the end*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">luaopen_orangleliu</span> <span class="params">(lua_State *L)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*注册lib， 上面luaopen_名称 跟下面注册的名称要一致, 还要和编译的.so文件名一致*/</span></span><br><span class="line">    luaL_register(L, <span class="string">"orangleliu"</span>, libs);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="编译">编译</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc <span class="operator">-f</span>PIC -shared -llua sleep.c -o orangleliu.so -I/usr/include/lua5.<span class="number">1</span> -std=gnu99</span><br></pre></td></tr></table></figure>
<h3 id="lua_调用">lua 调用</h3><h4 id="test-lua">test.lua</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span> <span class="string">"orangleliu"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">os</span>.time())</span><br><span class="line">orangleliu.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">os</span>.time())</span><br></pre></td></tr></table></figure>
<h4 id="调用结果">调用结果</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ lua test.lua</span><br><span class="line"><span class="number">1427118862</span></span><br><span class="line"><span class="number">1427118863</span></span><br></pre></td></tr></table></figure>
<h3 id="小结">小结</h3><p>基本的模板就是这样的，复杂一些就是多个参数和多个返回值。 如果有C基础，写起来还是挺快的，不过要是跨平台处理起来也挺麻烦的。<br>大家可以在github上搜下别人写的lua拓展库，参考下。</p>
<h3 id="参考">参考</h3><ul>
<li><a href="http://www.lua.org/pil/26.1.html" target="_blank" rel="external">Programming in Lua</a></li>
<li><a href="http://www.troubleshooters.com/codecorn/lua/lua_lua_calls_c.htm#_Make_an_msleep_Function" target="_blank" rel="external">Calling a C Function From Lua</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[ <a id="more"></a>
<blockquote>
<p>这几天在做一个小项目，其中用到了一些基本的API, 例如sleep，获取当前目录等等，lua标准库中没有提供这些接口，虽然所第三方库中也都有实现，但是要用的就那么几个函数，在一个嵌入式系统中安装那么多第三方库有]]>
    </summary>
    
      <category term="lua" scheme="http://orangleliu.info/tags/lua/"/>
    
      <category term="编程" scheme="http://orangleliu.info/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[nginx统计用户下载文件情况]]></title>
    <link href="http://orangleliu.info/2015/03/11/nginx-konw-user-download-file-completed/"/>
    <id>http://orangleliu.info/2015/03/11/nginx-konw-user-download-file-completed/</id>
    <published>2015-03-11T12:17:48.000Z</published>
    <updated>2015-11-04T12:10:20.000Z</updated>
    <content type="html"><![CDATA[ <a id="more"></a>
<blockquote>
<p>有一个需求是统计文件是否被用户完整下载，因为是web应用，用js没有找到实现方案，于是搜索下nginx的实现方案，把简单的探索过程记录下。</p>
</blockquote>
<h3 id="实验一">实验一</h3><ul>
<li>最原始的思路，查看日志，下载了一个文件之后我们看日志的传输的文件大小跟文件原始的大小是否一致</li>
<li>测试要下载的文件的大小</li>
</ul>
<p><img src="/img/filez_size.png" alt="测试文件"></p>
<ul>
<li>一次完整下载的log 跟一次没下载完成的log，可以通过对比传输字节的大小来判断</li>
</ul>
<p><img src="/img/nginx_log.png" alt="测试结果"></p>
<p>这种方式就是根据日志来做统计，每隔一段时间分析日志得到结果，有些麻烦，时效性不好。</p>
<h3 id="实验二：">实验二：</h3><p>找了相关的博客</p>
<ul>
<li><p><a href="https://www.linkedin.com/groups/Counting-100-completed-downloads-using-2000893.S.191692888" target="_blank" rel="external">Counting-100-completed-downloads</a><br>使用post_action（下面使用的方式）</p>
</li>
<li><p><a href="http://www.tipstuff.org/2012/08/Nginx-post-action-to-trigger-successfully-download-file.html" target="_blank" rel="external">Nginx-post-action-to-trigger-successfully-download-file</a> 遇到的问题 <a href="http://serverfault.com/questions/535429/nginx-post-action-proxy-pass-track-downloading-file" target="_blank" rel="external">nginx-post-action-proxy-pass-track-downloading-file</a></p>
</li>
<li><p>使用 x-accel-redirect</p>
<ul>
<li><a href="http://kovyrin.net/2006/11/01/nginx-x-accel-redirect-php-rails/" target="_blank" rel="external">nginx-x-accel-redirect-php-rails</a> 英文</li>
<li><a href="http://bianbian.org/154/利用nginx的x-accel-redirect头实现下载控制（附带php和rails实例代码）/" target="_blank" rel="external">利用nginx的x-accel-redirect头实现下载控制</a> 中文</li>
</ul>
</li>
</ul>
<p>大概的流程：</p>
<p><img src="/img/ngix.jpg" alt="结构"></p>
<p>主要的工作就是2个<br>1 修改nginx的配置，把下载文件的信息转发到统计服务或者url<br>2 统计服务记录和判断文件下载状态</p>
<p><strong>这里的重点是使用nginx 的post_action参数， 在下载请求结束之后把下载的情况发送给另一个统计服务，由统计服务来判断文件下载的情况</strong></p>
<p>配置类似</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    limit_rate <span class="number">20</span>k;</span><br><span class="line">    post_action @afterdownload;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location @afterdownload &#123;</span><br><span class="line">    proxy_pass http://<span class="number">127.0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">8888</span>/counting?FileName=<span class="variable">$uri</span>&amp;ClientIP=<span class="variable">$remote</span>_addr&amp;body_bytes_sent=<span class="variable">$body</span>_bytes_sent&amp;status=<span class="variable">$request</span>_completion;</span><br><span class="line">    internal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后写个一个flask 来接收统计请求</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment">############################</span></span><br><span class="line"><span class="comment">#File Name: counting_file.py</span></span><br><span class="line"><span class="comment">#Author: orangleliu</span></span><br><span class="line"><span class="comment">#Mail: orangleliu@gmail.com</span></span><br><span class="line"><span class="comment">#Created Time: 2015-03-11 16:41:05</span></span><br><span class="line"><span class="comment">#License: MIT</span></span><br><span class="line"><span class="comment">############################</span></span><br><span class="line"><span class="string">'''</span><br><span class="line">nginx统计用户下载文件字节</span><br><span class="line"></span><br><span class="line">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="decorator">@app.route("/counting")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">counting</span><span class="params">()</span>:</span></span><br><span class="line">    req = request.args.get(<span class="string">"FileName"</span>)</span><br><span class="line">    clientip = request.args.get(<span class="string">"ClientIP"</span>)</span><br><span class="line">    size = request.args.get(<span class="string">"body_bytes_sent"</span>)</span><br><span class="line">    status = request.args.get(<span class="string">"status"</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"request  "</span>, req</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"ip  "</span>, clientip</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"size  "</span>, size</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"status  "</span>, status</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ok"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app.run(port=<span class="number">8888</span>, debug=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>访问的日志</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">lzz@ubuntu:code$ python counting_file.py</span><br><span class="line"> * Running on http:<span class="comment">//127.0.0.1:8888/</span></span><br><span class="line"> * Restarting with reloader</span><br><span class="line">request   /index.html</span><br><span class="line">ip   <span class="number">10.0</span><span class="number">.1</span><span class="number">.16</span></span><br><span class="line">size   <span class="number">0</span></span><br><span class="line">status   OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> - - [<span class="number">12</span>/Mar/<span class="number">2015</span> <span class="number">10</span>:<span class="number">42</span>:<span class="number">59</span>] <span class="string">"GET /counting?FileName=/index.html&amp;ClientIP=10.0.1.16&amp;body_bytes_sent=0&amp;status=OK HTTP/1.0"</span> <span class="number">200</span> -</span><br><span class="line">request   /Pillow-<span class="number">2.3</span><span class="number">.0</span>.zip</span><br><span class="line">ip   <span class="number">10.0</span><span class="number">.1</span><span class="number">.16</span></span><br><span class="line">size   <span class="number">225280</span></span><br><span class="line">status</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> - - [<span class="number">12</span>/Mar/<span class="number">2015</span> <span class="number">10</span>:<span class="number">43</span>:<span class="number">14</span>] <span class="string">"GET /counting?FileName=/Pillow-2.3.0.zip&amp;ClientIP=10.0.1.16&amp;body_bytes_sent=225280&amp;status= HTTP/1.0"</span> <span class="number">200</span> -</span><br></pre></td></tr></table></figure>
<p>只要在flask中做处理就可以统计用户下载的情况了。<br>上面的文章也说了，当用户使用多个连接下载的时候可能就有问题了，会重复统计，结果也会不准确，所以还有很多改进空间.</p>
]]></content>
    <summary type="html">
    <![CDATA[ <a id="more"></a>
<blockquote>
<p>有一个需求是统计文件是否被用户完整下载，因为是web应用，用js没有找到实现方案，于是搜索下nginx的实现方案，把简单的探索过程记录下。</p>
</blockquote>
<h3 id="实验一">实验一<]]>
    </summary>
    
      <category term="nginx" scheme="http://orangleliu.info/tags/nginx/"/>
    
      <category term="后端开发" scheme="http://orangleliu.info/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[uwsgi+nginx deploy django project]]></title>
    <link href="http://orangleliu.info/2014/10/28/uwsgi-nginx-deploy-django-project/"/>
    <id>http://orangleliu.info/2014/10/28/uwsgi-nginx-deploy-django-project/</id>
    <published>2014-10-28T08:58:48.000Z</published>
    <updated>2015-11-04T12:13:15.000Z</updated>
    <content type="html"><![CDATA[ <a id="more"></a>
<h2 id="version">version</h2><ul>
<li>django version:1.6</li>
<li>os version: Centos 6.2</li>
<li>nginx version: 1.4.2</li>
<li>uwsgi version: 2.0.8</li>
<li>python version: 2.7.5</li>
</ul>
<h2 id="directory">directory</h2><p>1 django project is in <strong>/home/erya/hawk</strong> and settings.py is at <strong>/home/erya/hawk/settings.py</strong><br>2  <strong>nginx conf</strong> is at  <strong>/usr/local/nginx/conf</strong></p>
<h2 id="deployment">deployment</h2><ul>
<li>This is not a exhaustive reference, I assume all the softwares were installed correct.</li>
<li>I record some key point when deploy the project.</li>
<li>the web client &lt;-&gt; the web server &lt;-&gt; the socket &lt;-&gt; uwsgi &lt;-&gt; Django</li>
</ul>
<h3 id="small_test">small test</h3><p>use django dev server:   python manage.py runserver 8000   OK!<br>use uwsgi setup django:  uwsgi –http :8000 –module wsgi    OK!</p>
<p>it seems ok, the important parts coming!</p>
<h3 id="uwsgi_configure">uwsgi configure</h3><p>create uwsgi.ini file in django project directorythe file’s content is :</p>
<pre><code><span class="title">[uwsgi]</span>

<span class="setting">chdir=<span class="value">/home/erya/hawk</span></span>
<span class="setting">module=<span class="value">wsgi</span></span>

<span class="setting">master=<span class="value"><span class="keyword">True</span></span></span>
<span class="setting">processes=<span class="value"><span class="number">10</span></span></span>
<span class="setting">pidfile=<span class="value">/home/erya/hawk.pid</span></span>
<span class="setting">vacuum=<span class="value"><span class="keyword">True</span></span></span>
<span class="setting">max-requests=<span class="value"><span class="number">5000</span></span></span>
<span class="setting">enable-threads=<span class="value"><span class="keyword">True</span></span></span>
<span class="setting">socket=<span class="value"><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">9001</span></span></span>
</code></pre><h3 id="nginx_configure">nginx configure</h3><p>check  <strong>uwsgi_params </strong> file in nginx conf or you can donwload it from github <a href="https://github.com/nginx/nginx/blob/master/conf/uwsgi_params" target="_blank" rel="external">https://github.com/nginx/nginx/blob/master/conf/uwsgi_params</a><br>and put it in nginx conf directory.</p>
<p>add uwsgi.conf file,the content is :</p>
<pre><code>server {
        listen <span class="number">8000</span>;
        server_name <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>;
<span class="preprocessor">#       client_max_body_size <span class="number">64</span>M;</span>
        location / {
<span class="preprocessor">#           client_max_body_size <span class="number">4</span>M;</span>
            uwsgi_pass   <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9001</span>;
            include     uwsgi_params;
            access_log  off;
        }
}
</code></pre><p>add one line to nginx.conf ,like</p>
<pre><code>http {
    include       mime.types<span class="comment">;</span>
    default_type  application/octet-stream<span class="comment">;</span>


    sendfile        on<span class="comment">;</span>
    #tcp_nopush     on<span class="comment">;</span>

    #keepalive_timeout  0<span class="comment">;</span>
    keepalive_timeout  65<span class="comment">;</span>

    #gzip  on<span class="comment">;</span>
    include uwsgi.conf<span class="comment">;    ####here</span>
    ...
    server {
        ....
</code></pre><h2 id="start_up(the_use_have_the_permission)">start up(the use have the permission)</h2><p>uwsgi: in project directory</p>
<pre><code>uwsgi <span class="comment">--ini uwsgi.ini</span>
</code></pre><p>nginx:</p>
<pre><code><span class="regexp">/usr/</span>local<span class="regexp">/nginx/</span>sbin<span class="regexp">/nginx</span>
</code></pre><h2 id="Test">Test</h2><p>The you can open your favorite browser, type <a href="http://127.0.0.1:8000" target="_blank" rel="external">http://127.0.0.1:8000</a> , you will see your project’s index page.<br>Of course, what i do is very simple, you can config custom configure of your project.</p>
<h2 id="REF">REF</h2><p><a href="http://uwsgi-docs.readthedocs.org/en/latest/tutorials/Django_and_nginx.html" target="_blank" rel="external">django_and_nginx</a></p>
]]></content>
    <summary type="html">
    <![CDATA[ <a id="more"></a>
<h2 id="version">version</h2><ul>
<li>django version:1.6</li>
<li>os version: Centos 6.2</li>
<li>nginx version: 1.4.2</l]]>
    </summary>
    
      <category term="django nginx" scheme="http://orangleliu.info/tags/django-nginx/"/>
    
      <category term="后端开发" scheme="http://orangleliu.info/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[django-orm 聚合函数的使用]]></title>
    <link href="http://orangleliu.info/2014/10/28/django-orm-aggregation-class/"/>
    <id>http://orangleliu.info/2014/10/28/django-orm-aggregation-class/</id>
    <published>2014-10-28T08:58:48.000Z</published>
    <updated>2015-11-04T12:25:54.000Z</updated>
    <content type="html"><![CDATA[ <a id="more"></a>
<blockquote>
<p>orm对于普通的单表条件查询和多表的关联查询支持力度还可以，基本可以满足不是很复杂的业务场景，对于聚合函数也有一些支持，之前基本都没有用过，大部分都是使用raw sql来写的，今天把orm的聚合方法学习下，对于简单的聚合还是用orm自身来解决吧。</p>
</blockquote>
<p>一下笔记是基于django1.6</p>
<h2 id="django中提供的聚合方法"><a href="https://docs.djangoproject.com/en/1.6/ref/models/querysets/#aggregation-functions" target="_blank" rel="external">django中提供的聚合方法</a></h2><ul>
<li>Avg 求平均值，数字类型的字段支持</li>
<li>Count 统计个数， 可以增加dictinct选项 一般和annotate一起使用</li>
<li>Max 最大值</li>
<li>Mix  最小值</li>
<li>StdDev 计算给出字段的标准差</li>
<li>Sum 计算字段的和</li>
<li>Variance 计算字段的方差</li>
</ul>
<h2 id="聚合方法的使用"><a href="https://docs.djangoproject.com/en/1.6/topics/db/aggregation/" target="_blank" rel="external">聚合方法的使用</a></h2><p><a href="https://docs.djangoproject.com/en/1.6/topics/db/aggregation/" target="_blank" rel="external">文档地址</a></p>
<p>模型参见文档,这些查询都是可以和filter，order_by等一起使用的</p>
<blockquote>
<p> from django.db import models<br>    class Author(models.Model):<br>        name = models.CharField(max_length=100)<br>        age = models.IntegerField()</p>
</blockquote>
<pre><code>class <span class="function"><span class="title">Publisher</span><span class="params">(models.Model)</span></span>:
    name = models.<span class="function"><span class="title">CharField</span><span class="params">(max_length=<span class="number">300</span>)</span></span>
    num_awards = models.<span class="function"><span class="title">IntegerField</span><span class="params">()</span></span>

class <span class="function"><span class="title">Book</span><span class="params">(models.Model)</span></span>:
    name = models.<span class="function"><span class="title">CharField</span><span class="params">(max_length=<span class="number">300</span>)</span></span>
    pages = models.<span class="function"><span class="title">IntegerField</span><span class="params">()</span></span>
    price = models.<span class="function"><span class="title">DecimalField</span><span class="params">(max_digits=<span class="number">10</span>, decimal_places=<span class="number">2</span>)</span></span>
    rating = models.<span class="function"><span class="title">FloatField</span><span class="params">()</span></span>
    authors = models.<span class="function"><span class="title">ManyToManyField</span><span class="params">(Author)</span></span>
    publisher = models.<span class="function"><span class="title">ForeignKey</span><span class="params">(Publisher)</span></span>
    pubdate = models.<span class="function"><span class="title">DateField</span><span class="params">()</span></span>

class <span class="function"><span class="title">Store</span><span class="params">(models.Model)</span></span>:
    name = models.<span class="function"><span class="title">CharField</span><span class="params">(max_length=<span class="number">300</span>)</span></span>
    books = models.<span class="function"><span class="title">ManyToManyField</span><span class="params">(Book)</span></span>
    registered_users = models.<span class="function"><span class="title">PositiveIntegerField</span><span class="params">()</span></span>
</code></pre><p>查询例子</p>
<pre><code><span class="comment">#得到所有书的总量</span>
Book.objects.count()
<span class="comment">#求平均值，最大值，最小值用法基本相似</span>
<span class="keyword">from</span> django.db.models <span class="keyword">import</span> Avg
Book.objects.all().aggregate(Avg(<span class="string">'price'</span>))
{<span class="string">'price__avg'</span>: <span class="number">34.35</span>}  <span class="comment">#返回值是一个字典类型，key的名字好像不是很友好</span>

<span class="comment">#计算每个出版社，出版书的数目</span>
<span class="keyword">from</span> django.db.models <span class="keyword">import</span> Count
pubs = Publisher.objects.annotate(num_books=Count(<span class="string">'book'</span>))
<span class="comment">#计算所有出版社出版书数目最多的5个出版社</span>
pubs = Publisher.objects.annotate(num_books=Count(<span class="string">'book'</span>)).order_by(<span class="string">'-num_books'</span>)[:<span class="number">5</span>]
pubs[<span class="number">0</span>].num_books
<span class="number">1323</span>

<span class="comment">#返回值别名</span>
Book.objects.aggregate(average_price=Avg(<span class="string">'price'</span>))  <span class="comment">#添加了一个average_price来作为返回值的key</span>
{<span class="string">'average_price'</span>: <span class="number">34.35</span>}

<span class="comment">#连表查询  跟filter中很相似使用 __来关联到其他表</span>
Store.objects.aggregate(min_price=Min(<span class="string">'books__price'</span>), max_price=Max(<span class="string">'books__price'</span>))

<span class="comment">#也可以把聚合和计数同时使用</span>
<span class="comment">#计算每个作者平均出版书的数目</span>
<span class="keyword">from</span> django.db.models <span class="keyword">import</span> Count, Avg
Book.objects.annotate(num_authors=Count(<span class="string">'authors'</span>)).aggregate(Avg(<span class="string">'num_authors'</span>))
</code></pre><p>以上只是对文档的理解，具体使用还需要具体看业务需求。</p>
]]></content>
    <summary type="html">
    <![CDATA[ <a id="more"></a>
<blockquote>
<p>orm对于普通的单表条件查询和多表的关联查询支持力度还可以，基本可以满足不是很复杂的业务场景，对于聚合函数也有一些支持，之前基本都没有用过，大部分都是使用raw sql来写的，今天把orm的聚合方法学习下，对于]]>
    </summary>
    
      <category term="orm" scheme="http://orangleliu.info/tags/orm/"/>
    
      <category term="django" scheme="http://orangleliu.info/categories/django/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[django 利用多线程处理异步任务]]></title>
    <link href="http://orangleliu.info/2014/10/24/django-use-mutil-thread-async/"/>
    <id>http://orangleliu.info/2014/10/24/django-use-mutil-thread-async/</id>
    <published>2014-10-24T08:58:48.000Z</published>
    <updated>2015-11-04T12:21:02.000Z</updated>
    <content type="html"><![CDATA[ <a id="more"></a>
<blockquote>
<p>看到django异步大家的反应应该是celery这种消息队列组件，现在用的最多的最推荐的也是这种方式。然而我这需求就是<br>请求来了，执行一个小程序，但是又不能确定这个小程序啥时候执行完，响应又要及时，丢给队列处理当然可以，但是<br>为了简单，决定直接起个线程跑跑。 （当然这只是实验，应用规模也很小，如果并发高，会有很多问题）</p>
</blockquote>
<p>从view.py中截取了这段代码:</p>
<pre><code><span class="decorator">@login_required</span>
<span class="function"><span class="keyword">def</span> <span class="title">search_area</span><span class="params">(request)</span>:</span>
    prints = PrintThread()
    prints.start()

    <span class="keyword">return</span> retrieve(request, <span class="string">'Area'</span>, <span class="string">'areasearche.html'</span>, [{<span class="string">'name'</span>:<span class="string">'areaname'</span>, <span class="string">'mode'</span>: <span class="string">'contains'</span>}])

<span class="comment">##通过thread 实现django中</span>
<span class="keyword">import</span> threading
<span class="keyword">import</span> time
<span class="class"><span class="keyword">class</span> <span class="title">PrintThread</span><span class="params">(threading.Thread)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span>
        <span class="keyword">print</span> <span class="string">"start.... %s"</span>%(self.getName(),)
        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>):
            time.sleep(<span class="number">1</span>)
            <span class="keyword">print</span> i
        <span class="keyword">print</span> <span class="string">"end.... %s"</span>%(self.getName(),)
</code></pre><p>从执行的结果来看是可以完成需求的，</p>
<pre><code>start.... Thread-<span class="number">7</span>
<span class="number">0</span>
<span class="number">1</span>
<span class="number">2</span>
[<span class="number">24</span>/Oct/<span class="number">2014</span> <span class="number">15</span>:<span class="number">09</span>:<span class="number">30</span>] <span class="string">"GET /media/js/hawk.js HTTP/1.1"</span> <span class="number">304</span> <span class="number">0</span>
<span class="number">3</span>
...
<span class="number">26</span>
<span class="number">27</span>
<span class="number">28</span>
<span class="number">29</span>
end.... Thread-<span class="number">7</span>
</code></pre><p>对于定时延迟任务，还有高并发的异步任务还用mq来的方面。</p>
]]></content>
    <summary type="html">
    <![CDATA[ <a id="more"></a>
<blockquote>
<p>看到django异步大家的反应应该是celery这种消息队列组件，现在用的最多的最推荐的也是这种方式。然而我这需求就是<br>请求来了，执行一个小程序，但是又不能确定这个小程序啥时候执行完，响应又要及时，丢给队]]>
    </summary>
    
      <category term="多线程" scheme="http://orangleliu.info/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="django" scheme="http://orangleliu.info/categories/django/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[django-debug-tools 使用]]></title>
    <link href="http://orangleliu.info/2014/10/22/django-debug-tools-use/"/>
    <id>http://orangleliu.info/2014/10/22/django-debug-tools-use/</id>
    <published>2014-10-22T04:58:48.000Z</published>
    <updated>2015-11-04T12:27:25.000Z</updated>
    <content type="html"><![CDATA[ <a id="more"></a>
<blockquote>
<p>用django开发很快也很容易，但是很多时候我们的经验并不是很足，就会给自己挖下很多坑，不管是性能问题，还是开发语言使用技巧问题都会给应用的稳定带来危害， 开发之后的调试和调优就显得很重要，今天就尝试使用django-debug-toolbar来给我们的开发增加更多的调试和监控。之前只是听说过，没有具体应用过。</p>
</blockquote>
<p>我这里是python1.6。  1.7的配置有点小改动，具体看<a href="(http://django-debug-toolbar.readthedocs.org/en/1.2/installation.html">文档</a>)。</p>
<h2 id="安装">安装</h2><p>使用pip安装</p>
<pre><code><span class="title">pip</span> install django-<span class="built_in">debug</span>-toolbar
</code></pre><p><a href="http://django-debug-toolbar.readthedocs.org/en/1.2/installation.html" target="_blank" rel="external">参考地址</a></p>
<h2 id="配置">配置</h2><h3 id="基本配置">基本配置</h3><p>修改settings.py 中的配置</p>
<p>添加app，INSTALLED_APPS添加</p>
<pre><code><span class="title">INSTALLED_APPS</span> = (
    <span class="comment"># ...</span>
    <span class="string">'django.contrib.staticfiles'</span>,
    <span class="comment"># ...</span>
    <span class="comment"># If you're using Django 1.7.x or later</span>
    <span class="string">'debug_toolbar.apps.DebugToolbarConfig'</span>,
    <span class="comment"># If you're using Django 1.6.x or earlier</span>
    <span class="string">'debug_toolbar'</span>,
)
</code></pre><p>还要设置成debug模式</p>
<pre><code><span class="setting">DEBUG = <span class="value"><span class="keyword">True</span></span></span>
</code></pre><p>文档中说这种配置方式使用runserver 可以，但是其他方式启动可能需要就要更多的配置了。<br><a href="http://django-debug-toolbar.readthedocs.org/en/1.2/installation.html#explicit-setup" target="_blank" rel="external">详细参照</a></p>
<p>还有一些高级的自定义配置 <a href="http://django-debug-toolbar.readthedocs.org/en/1.2/configuration.html" target="_blank" rel="external">configuration.</a></p>
<p><a href="http://django-debug-toolbar.readthedocs.org/en/1.2/index.html" target="_blank" rel="external">更多更详细的配置</a></p>
<h2 id="使用">使用</h2><p>这里我们就使用默认的配置</p>
<p>启动django的开发服务器。 进入项目中</p>
<ul>
<li><p>发现浏览的又上方有个图标,如下图：<br><img src="/img/django_debug1.png" alt="django-debug" title="django"></p>
</li>
<li><p>点击图标可以看到debug的一些选项如下图。<br><img src="/img/django_debug2.png" alt="django-debug" title="django"></p>
</li>
<li><p>我们来查看下sql的执行（下图），可以看到sql的执行总时间，多少条，每个sql的执行时间，sql语句等等。 还是很详细的。<br><img src="/img/django_debug3.png" alt="django-debug" title="django"></p>
</li>
</ul>
<h2 id="小结">小结</h2><p>从试用的角度来看，debug-tool还是很强大的，给我们的开发和调试带来很多的方面。</p>
<h2 id="jquery配置">jquery配置</h2><p>今天使用的时候发现里面默认的jquery配置是google的cdn，由于f的原因，我们在settings中配置一个非国外的源</p>
<pre><code>DEBUG_TOOLBAR_CONFIG = {
    <span class="string">'JQUERY_URL'</span> : <span class="string">"http://code.jquery.com/jquery-2.1.1.min.js"</span>
}
</code></pre><p>这样就可以正常使用了。</p>
]]></content>
    <summary type="html">
    <![CDATA[ <a id="more"></a>
<blockquote>
<p>用django开发很快也很容易，但是很多时候我们的经验并不是很足，就会给自己挖下很多坑，不管是性能问题，还是开发语言使用技巧问题都会给应用的稳定带来危害， 开发之后的调试和调优就显得很重要，今天就尝试使用dja]]>
    </summary>
    
      <category term="debug" scheme="http://orangleliu.info/tags/debug/"/>
    
      <category term="django" scheme="http://orangleliu.info/categories/django/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Django的orm中get和filter的不同]]></title>
    <link href="http://orangleliu.info/2014/08/15/Django-orm-get-filter-differ/"/>
    <id>http://orangleliu.info/2014/08/15/Django-orm-get-filter-differ/</id>
    <published>2014-08-15T15:59:48.000Z</published>
    <updated>2015-11-04T12:24:56.000Z</updated>
    <content type="html"><![CDATA[ <a id="more"></a>
<blockquote>
<p>Django的orm框架对于业务复杂度不是很高的应用来说还是不错的，写起来很方面，用起来也简单。对于新手来说查询操作中最长用的两个方法get和filter有时候一不注意就会犯下一些小错误。那么今天就来小节下这两个方法使用上的不同。</p>
</blockquote>
<p>我常用的是1.5版本的django，就以此为例来说说吧。</p>
<h2 id="文档">文档</h2><p>首先对比下两个函数<a href="https://docs.djangoproject.com/en/1.5/ref/models/querysets/" target="_blank" rel="external">文档</a>上的解释。</p>
<p><strong>get</strong></p>
<blockquote>
<p>Returns the object matching the given lookup parameters, which should be in the format described in Field lookups.</p>
<p>get() raises MultipleObjectsReturned if more than one object was found. The MultipleObjectsReturned exception is an attribute of the model class.</p>
<p>get() raises a DoesNotExist exception if an object wasn’t found for the given parameters. This exception is also an attribute of the model class</p>
</blockquote>
<p><strong>filter</strong></p>
<blockquote>
<p>Returns a new QuerySet containing objects that do not match the given lookup parameters.</p>
<p>The lookup parameters (**kwargs) should be in the format described in Field lookups below. Multiple parameters are joined via AND in the underlying SQL statement, and the whole thing is enclosed in a NOT().</p>
</blockquote>
<ul>
<li><p>输入参数<br><strong>get</strong>  的参数只能是model中定义的那些字段，只支持严格匹配<br><strong>filter</strong>  的参数可以是字段，也可以是扩展的where查询关键字，如in，like等</p>
</li>
<li><p>返回值<br><strong>get</strong> 返回值是一个定义的model对象<br><br><strong>filter</strong> 返回值是一个新的QuerySet对象，然后可以对QuerySet在进行查询返回新的QuerySet对象，支持链式操作</p>
<pre><code>QuerySet一个集合对象，可使用迭代或者遍历，切片等，但是<span class="keyword">*</span><span class="keyword">*</span>不等于list类型(使用一定要注意)<span class="keyword">*</span><span class="keyword">*</span>
</code></pre></li>
<li><p>异常<br><strong>get</strong>  只有一条记录返回的时候才正常,也就说明get的查询字段必须是主键或者唯一约束的字段。当返回多条记录或者是没有找到记录的时候都会抛出异常<br><br><strong>filter</strong> 有没有匹配的记录都可以</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[ <a id="more"></a>
<blockquote>
<p>Django的orm框架对于业务复杂度不是很高的应用来说还是不错的，写起来很方面，用起来也简单。对于新手来说查询操作中最长用的两个方法get和filter有时候一不注意就会犯下一些小错误。那么今天就来小节下这两]]>
    </summary>
    
      <category term="queryset" scheme="http://orangleliu.info/tags/queryset/"/>
    
      <category term="django" scheme="http://orangleliu.info/categories/django/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在Python和IPython中使用Docker]]></title>
    <link href="http://orangleliu.info/2014/08/09/user-docker-in-python-and-ipython/"/>
    <id>http://orangleliu.info/2014/08/09/user-docker-in-python-and-ipython/</id>
    <published>2014-08-09T12:17:48.000Z</published>
    <updated>2015-11-04T12:16:37.000Z</updated>
    <content type="html"><![CDATA[ <a id="more"></a>
<p>现在Docker是地球上最炙手可热的项目之一，就意味着人民实际上不仅仅是因为这个才喜欢它。<br>话虽如此，我非常喜欢使用容器，服务发现以及所有被创造出的新趣的点子和领域来切换工作作为范例。<br>这个文章中我会简要介绍使用python中的docker-py模块来操作Docker 容器，这里会使用我喜爱的编程工具IPython。</p>
<p>##安装docker-py<br>首先需要docker-py。注意这里的案例中我将会使用Ubuntu Trusty 14.04版本。</p>
<pre><code>$ pip <span class="keyword">install</span> docker-py
</code></pre><h2 id="IPyhton">IPyhton</h2><p>我真的很喜欢用IPython来探索Python。 它像是一共高级的python Shell，但是可以做的更多。</p>
<pre><code>$ sudo apt-get <span class="operator"><span class="keyword">install</span> ipython
SNIP!
$ ipython
Python <span class="number">2.7</span><span class="number">.6</span> (<span class="keyword">default</span>, Mar <span class="number">22</span> <span class="number">2014</span>, <span class="number">22</span>:<span class="number">59</span>:<span class="number">56</span>)
<span class="keyword">Type</span> <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.

IPython <span class="number">1.2</span><span class="number">.1</span> <span class="comment">-- An enhanced Interactive Python.</span>
?         -&gt; Introduction <span class="keyword">and</span> overview <span class="keyword">of</span> IPython<span class="string">'s features.
%quickref -&gt; Quick reference.
help      -&gt; Python'</span>s own <span class="keyword">help</span> <span class="keyword">system</span>.
<span class="keyword">object</span>?   -&gt; Details about <span class="string">'object'</span>, <span class="keyword">use</span> <span class="string">'object??'</span> <span class="keyword">for</span> extra details.

<span class="keyword">In</span> [<span class="number">1</span>]:</span>
</code></pre><h2 id="安装_docker">安装 docker</h2><p>如果没有安装Docker，那首先安装docker</p>
<pre><code>$ sudo apt-<span class="keyword">get</span> install docker.io
</code></pre><p>然后把 docker.io 起个别名 docker</p>
<pre><code>$ alias docker='docker.io'
$ docker version
Client version: 0.9.1
Go version (client): go1.2.1
Git <span class="operator"><span class="keyword">commit</span> (<span class="keyword">client</span>): <span class="number">3600720</span>
<span class="keyword">Server</span> <span class="keyword">version</span>: <span class="number">0.9</span><span class="number">.1</span>
Git <span class="keyword">commit</span> (<span class="keyword">server</span>): <span class="number">3600720</span>
<span class="keyword">Go</span> <span class="keyword">version</span> (<span class="keyword">server</span>): go1<span class="number">.2</span><span class="number">.1</span>
<span class="keyword">Last</span> stable <span class="keyword">version</span>: <span class="number">0.11</span><span class="number">.1</span>, please <span class="keyword">update</span> docker</span>
</code></pre><p>Docker现在应该有个socket开启，我们可以用来连接。</p>
<pre><code>$ <span class="keyword">ls</span> /<span class="keyword">var</span>/<span class="keyword">run</span>/docker.sock
/<span class="keyword">var</span>/<span class="keyword">run</span>/docker.sock
</code></pre><h2 id="Pull_镜像">Pull 镜像</h2><p>让我们下载 busybox镜像</p>
<pre><code>$ docker pull busybox
Pulling repository busybox
<span class="number">71e18</span><span class="string">d715071:</span> Download complete
<span class="number">98</span><span class="string">b9fdab1cb6:</span> Download complete
<span class="number">1277</span><span class="string">aa3f93b3:</span> Download complete
<span class="number">6e0</span><span class="string">a2595b580:</span> Download complete
<span class="number">511136</span><span class="string">ea3c5a:</span> Download complete
<span class="string">b6c0d171b362:</span> Download complete
<span class="number">8464</span><span class="string">f9ac64e8:</span> Download complete
<span class="number">9798716626</span><span class="string">f6:</span> Download complete
<span class="string">fc1343e2fca0:</span> Download complete
<span class="string">f3c823ac7aa6:</span> Download complete
</code></pre><p>现在我们准备使用 docker-py 了。</p>
<h2 id="使用_docker-py">使用 docker-py</h2><p>现在我们有了docker-py , IPython, Docker 和 busybox 镜像，我们就能建立一些容器。<br>如果你不是很熟悉IPython，可以参照这个教程学习（<a href="http://ipython.org/ipython-doc/stable/interactive/tutorial.html），" target="_blank" rel="external">http://ipython.org/ipython-doc/stable/interactive/tutorial.html），</a><br>IPython是十分强大的。</p>
<p>首先启动一个IPython ，导入docker模块。</p>
<pre><code>$ ipython
Python <span class="number">2.7</span>.<span class="number">6</span> (<span class="keyword">default</span>, Mar <span class="number">22</span> <span class="number">2014</span>, <span class="number">22</span>:<span class="number">59</span>:<span class="number">56</span>)
<span class="keyword">Type</span> <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.

IPython <span class="number">1.2</span>.<span class="number">1</span> <span class="comment">-- An enhanced Interactive Python.</span>
?         -&gt; Introduction <span class="keyword">and</span> overview <span class="keyword">of</span> IPython<span class="attribute">'s</span> features.
%quickref -&gt; Quick reference.
help      -&gt; Python<span class="attribute">'s</span> own help system.
object?   -&gt; Details about <span class="attribute">'object</span>', <span class="keyword">use</span> <span class="attribute">'object</span>??' <span class="keyword">for</span> extra details.

<span class="keyword">In</span> [<span class="number">1</span>]: import docker
</code></pre><p>然后我们建立一个连接到Docker</p>
<pre><code>In [<span class="number">2</span>]: c = docker.Client(base_url=<span class="string">'unix://var/run/docker.sock'</span>,
   <span class="keyword">...</span>:                   version=<span class="string">'1.9'</span>,
   <span class="keyword">...</span>:                   timeout=<span class="number">10</span>)
</code></pre><p>现在我们已经连接到Docker。</p>
<p>IPython使用tab键来补全的。 如果 输入 “c.” 然后按下tab键，IPython会显示Docker连接对象所有的方法和属性。</p>
<pre><code>In [<span class="number">3</span>]: c.
c<span class="class">.adapters</span>                      c<span class="class">.headers</span>                       c<span class="class">.pull</span>
c<span class="class">.attach</span>                        c<span class="class">.history</span>                       c<span class="class">.push</span>
c<span class="class">.attach_socket</span>                 c<span class="class">.hooks</span>                         c<span class="class">.put</span>
c<span class="class">.auth</span>                          c<span class="class">.images</span>                        c<span class="class">.remove_container</span>
c<span class="class">.base_url</span>                      c<span class="class">.import_image</span>                  c<span class="class">.remove_image</span>
c<span class="class">.build</span>                         c<span class="class">.info</span>                          c<span class="class">.request</span>
c<span class="class">.cert</span>                          c<span class="class">.insert</span>                        c<span class="class">.resolve_redirects</span>
c<span class="class">.close</span>                         c<span class="class">.inspect_container</span>             c<span class="class">.restart</span>
c<span class="class">.commit</span>                        c<span class="class">.inspect_image</span>                 c<span class="class">.search</span>
c<span class="class">.containers</span>                    c<span class="class">.kill</span>                          c<span class="class">.send</span>
c<span class="class">.cookies</span>                       c<span class="class">.login</span>                         c<span class="class">.start</span>
c<span class="class">.copy</span>                          c<span class="class">.logs</span>                          c<span class="class">.stop</span>
c<span class="class">.create_container</span>              c<span class="class">.max_redirects</span>                 c<span class="class">.stream</span>
c<span class="class">.create_container_from_config</span>  c<span class="class">.mount</span>                         c<span class="class">.tag</span>
c<span class="class">.delete</span>                        c<span class="class">.options</span>                       c<span class="class">.top</span>
c<span class="class">.diff</span>                          c<span class="class">.params</span>                        c<span class="class">.trust_env</span>
c<span class="class">.events</span>                        c<span class="class">.patch</span>                         c<span class="class">.verify</span>
c<span class="class">.export</span>                        c<span class="class">.port</span>                          c<span class="class">.version</span>
c<span class="class">.get</span>                           c<span class="class">.post</span>                          c<span class="class">.wait</span>
c<span class="class">.get_adapter</span>                   c<span class="class">.prepare_request</span>
c<span class="class">.head</span>                          c.proxies
</code></pre><p>让我们来看下c.images   我输入一个 “?”在c.之后，ipython 会提供这个对象的详细信息。</p>
<pre><code><span class="keyword">In</span> [<span class="number">5</span>]: c.images?
<span class="keyword">Type</span>:       instancemethod
String Form:&lt;bound <span class="function"><span class="keyword">method</span> <span class="title">Client</span>.<span class="title">images</span> <span class="title">of</span> &lt;<span class="title">docker</span>.<span class="title">client</span>.<span class="title">Client</span> <span class="title">object</span> <span class="title">at</span> 0<span class="title">x7f3acc731790</span>&gt;&gt;
<span class="title">File</span>:</span>       /usr/local/lib/python2.<span class="number">7</span>/dist-packages/docker/client.py
Definition: c.images(<span class="keyword">self</span>, name=None, quiet=<span class="keyword">False</span>, all=<span class="keyword">False</span>, viz=<span class="keyword">False</span>)
Docstring:  &lt;no docstring&gt;
</code></pre><p>获取busybox 镜像。</p>
<pre><code>In [<span class="number">6</span>]: c.images(name=<span class="string">"busybox"</span>)
Out[<span class="number">6</span>]:
[{<span class="string">u'Created'</span>: <span class="number">1401402591</span>,
  <span class="string">u'Id'</span>: <span class="string">u'71e18d715071d6ba89a041d1e696b3d201e82a7525fbd35e2763b8e066a3e4de'</span>,
  <span class="string">u'ParentId'</span>: <span class="string">u'8464f9ac64e87252a91be3fbb99cee20cda3188de5365bec7975881f389be343'</span>,
  <span class="string">u'RepoTags'</span>: [<span class="string">u'busybox:buildroot-2013.08.1'</span>],
  <span class="string">u'Size'</span>: <span class="number">0</span>,
  <span class="string">u'VirtualSize'</span>: <span class="number">2489301</span>},
 {<span class="string">u'Created'</span>: <span class="number">1401402590</span>,
  <span class="string">u'Id'</span>: <span class="string">u'1277aa3f93b3da774690bc4f0d8bf257ff372e23310b4a5d3803c180c0d64cd5'</span>,
  <span class="string">u'ParentId'</span>: <span class="string">u'f3c823ac7aa6ef78d83f19167d5e2592d2c7f208058bc70bf5629d4bb4ab996c'</span>,
  <span class="string">u'RepoTags'</span>: [<span class="string">u'busybox:ubuntu-14.04'</span>],
  <span class="string">u'Size'</span>: <span class="number">0</span>,
  <span class="string">u'VirtualSize'</span>: <span class="number">5609404</span>},
 {<span class="string">u'Created'</span>: <span class="number">1401402589</span>,
  <span class="string">u'Id'</span>: <span class="string">u'6e0a2595b5807b4f8c109f3c6c5c3d59c9873a5650b51a4480b61428427ab5d8'</span>,
  <span class="string">u'ParentId'</span>: <span class="string">u'fc1343e2fca04a455f803ba66d1865739e0243aca6c9d5fd55f4f73f1e28456e'</span>,
  <span class="string">u'RepoTags'</span>: [<span class="string">u'busybox:ubuntu-12.04'</span>],
  <span class="string">u'Size'</span>: <span class="number">0</span>,
  <span class="string">u'VirtualSize'</span>: <span class="number">5454693</span>},
 {<span class="string">u'Created'</span>: <span class="number">1401402587</span>,
  <span class="string">u'Id'</span>: <span class="string">u'98b9fdab1cb6e25411eea5c44241561326c336d3e0efae86e0239a1fe56fbfd4'</span>,
  <span class="string">u'ParentId'</span>: <span class="string">u'9798716626f6ae4e6b7f28451c0a1a603dc534fe5d9dd3900150114f89386216'</span>,
  <span class="string">u'RepoTags'</span>: [<span class="string">u'busybox:buildroot-2014.02'</span>, <span class="string">u'busybox:latest'</span>],
  <span class="string">u'Size'</span>: <span class="number">0</span>,
  <span class="string">u'VirtualSize'</span>: <span class="number">2433303</span>}]
</code></pre><p>建立一个容器。 注意我添加一个可以将要运行的命令，这里用的是”env”命令。</p>
<pre><code>In [<span class="number">8</span>]: c.create_container(image=<span class="string">"busybox"</span>, command=<span class="string">"env"</span>)
Out[<span class="number">8</span>]:
{<span class="string">u'Id'</span>: <span class="string">u'584459a09e6d4180757cb5c10ac354ca46a32bf8e122fa3fb71566108f330c87'</span>,
 <span class="string">u'Warnings'</span>: <span class="keyword">None</span>}
</code></pre><p>使用ID来启动这个容器</p>
<pre><code>In [<span class="number">9</span>]: c.<span class="function"><span class="title">start</span><span class="params">(container=<span class="string">"584459a09e6d4180757cb5c10ac354ca46a32bf8e122fa3fb71566108f330c87"</span>)</span></span>
</code></pre><p>我们可以检查日志，应该可以看到当容器创建的时候 ，我们配置的”env”命令的输出。</p>
<pre><code>In <span class="special">[</span>11<span class="special">]</span>: c.logs(container="584459a09e6d4180757cb5c10ac354ca46a32bf8e122fa3fb71566108f330c87")
Out<span class="special">[</span>11<span class="special">]</span>: 'HOME=/<span class="command">\nPATH</span>=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin<span class="command">\nHOSTNAME</span>=<span class="number">584459</span>a09e6d<span class="command">\n</span>'
</code></pre><p>如果使用docker命令行，使用同样的命令行选项运行一个容器，应该可以看到类似的信息。</p>
<pre><code>$ docker run busybox env
HOME=/
PATH=<span class="regexp">/usr/</span>local<span class="regexp">/sbin:/</span>usr<span class="regexp">/local/</span><span class="string">bin:</span><span class="regexp">/usr/</span><span class="string">sbin:</span><span class="regexp">/usr/</span><span class="string">bin:</span><span class="regexp">/sbin:/</span>bin
HOSTNAME=ce3ad38a52bf
</code></pre><p>据我所知，docker-py没有运行选项，我们只能创建一个容器然后启动它。</p>
<p>以下是一个案例：</p>
<pre><code><span class="keyword">In</span> [17]: busybox = c.create_container(image=<span class="string">"busybox"</span>, command=<span class="string">"echo hi"</span>)

<span class="keyword">In</span> [18]: busybox?
<span class="keyword">Type</span>:       dict
String <span class="keyword">Form</span>:{<span class="keyword">u</span>'Id': <span class="keyword">u</span>'34ede853ee0e95887ea333523d559efae7dcbe6ae7147aa971c544133a72e254', <span class="keyword">u</span>'Warnings': None}
Length:     2
Docstring:
dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object'<span class="literal">s</span>
    (key, value) pairs
dict(iterable) -&gt; new dictionary initialized <span class="keyword">as</span> <span class="keyword">if</span> via:
    <span class="keyword">d</span> = {}
    <span class="keyword">for</span> k, v <span class="keyword">in</span> iterable:
        <span class="keyword">d</span>[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
    <span class="keyword">in</span> the keyword argument <span class="keyword">list</span>.  <span class="keyword">For</span> example:  dict(<span class="keyword">one</span>=1, <span class="keyword">two</span>=2)

<span class="keyword">In</span> [19]: c.start(busybox.<span class="literal">get</span>(<span class="string">"Id"</span>))

<span class="keyword">In</span> [20]: c.logs(busybox.<span class="literal">get</span>(<span class="string">"Id"</span>))
<span class="keyword">Out</span>[20]: 'hi\<span class="keyword">n</span>'
</code></pre><p>如果你还没有使用过busybox镜像，我建议你使用下。我也建议debain下的jessie镜像，它只有120MB，比Ubuntu镜像要小。</p>
<h2 id="总结">总结</h2><p>Docker是一个吸引人的新系统，可以用来建立有趣的新技术应用，特别是云服务相关的。使用IPython我们探索了怎么使用<br>docker-py模块来创建docker 容器。 现在使用python，我们可以结合docker和容易 创造出很多新的点子。</p>
<h2 id="原文">原文</h2><p>原文地址：<a href="http://serverascode.com/2014/06/05/docker-python.html" target="_blank" rel="external">http://serverascode.com/2014/06/05/docker-python.html</a><br>orangleliu  @2014-07-13</p>
]]></content>
    <summary type="html">
    <![CDATA[ <a id="more"></a>
<p>现在Docker是地球上最炙手可热的项目之一，就意味着人民实际上不仅仅是因为这个才喜欢它。<br>话虽如此，我非常喜欢使用容器，服务发现以及所有被创造出的新趣的点子和领域来切换工作作为范例。<br>这个文章中我会简要介绍使用python]]>
    </summary>
    
      <category term="docker" scheme="http://orangleliu.info/tags/docker/"/>
    
      <category term="翻译" scheme="http://orangleliu.info/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Celery最佳实践-正确使用celery的7条建议]]></title>
    <link href="http://orangleliu.info/2014/08/09/celery-best-practice/"/>
    <id>http://orangleliu.info/2014/08/09/celery-best-practice/</id>
    <published>2014-08-09T12:17:48.000Z</published>
    <updated>2015-11-04T12:01:44.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p><a href="http://blog.csdn.net/orangleliu" target="_blank" rel="external">orangleliu</a> 翻译  <a href="https://denibertovic.com/posts/celery-best-practices/" target="_blank" rel="external">原文点击查看</a></p>
</blockquote>
<p> 如果你的工作和 <a href="https://www.djangoproject.com/" target="_blank" rel="external">Django</a> 相关, 并且有时候需要执行一些长时间的后台任务。可能你已经使用了某种任务队列，<a href="http://www.celeryproject.org/" target="_blank" rel="external">Celery</a>就是Python（和Django）世界中时下解决类似问题最受欢迎的项目。</p>
<p>当在某些项目使用Celery作为任务队列之后，我总结了一些最佳实践，决定把它们些下来。然而，这里也有一些对自己应该做的却没做的反思，还有一些celery提供但是没有充分利用的功能。</p>
<h3 id="No-1_不要使用关系型数据库来作为AMQP的代理">No.1  不要使用关系型数据库来作为AMQP的代理</h3><p>让我来解释下我为什么觉得这是错的。</p>
<p>关系型数据库不像RabbitMQ一样专门作为AMQP代理而设计。它会在某个时间点挂掉，可能在生产中没法那么基于 传输/用户。</p>
<p>我猜测人们使用关系型数据库的最大原因是，已经有了一个数据库为web应用工作，为啥不复用呢。配置非常简单并且你不需要在担心其他的组件（像RabbitMQ）</p>
<p>假设这样的场景：你有4个后台工作的进程，你把这些任务放到数据库中。这意味着有四个进程相当频繁地去数据库轮询，检查是否有新的任务，这还不包括这4个进程本身也是多个进程。在某些时刻你会发现你的任务进程很慢，有些任务还没处理就有更多的任务进来了，你就自然的增加worker来处理任务。大量的worker为了获取新任务轮询数据库，导致数据库突然变慢，磁盘IO达到瓶颈，你的web应用也会受此影响变得越来越慢，因为这些worker正在对数据库进行基本的DDOS 攻击。</p>
<p>当你有一个像RabbitMQ这样的AMQP代理的时候，这些情况就不会发生了，因为这些队列是存在于内存当中，所以也不会伤害到你的硬盘。这些worker不需要频繁的轮询，因为队列会把新的任务推送给worker，如果AMQP因为某些原因不能工作了，至少不会影响到web应用的所有使用。</p>
<p>我不得不说你也不应该在开发环境中使用关系型数据库来作为代理，像Docker和预先建立好的镜像都能给你一个沙盒中的RabbitMQ环境使用。</p>
<h3 id="NO-2_使用多个Queues（队列），不要只是使用默认的那个（default）">NO.2 使用多个Queues（队列），不要只是使用默认的那个（default）</h3><p>Celery的启动是相当的简单，它会启动一个默认的队列，除非你定义了别的队列否则它就会把所有的任务放到这一个队列中去。最常见的就是像下面这样。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@app.task()</span><br><span class="line">def my_taskA(a, b, c):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"doing something here..."</span>)</span><br><span class="line"></span><br><span class="line">@app.task()</span><br><span class="line">def my_taskB(x, y):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"doing something here..."</span>)</span><br></pre></td></tr></table></figure>
<p>两个任务会放到同一个队列中去(如果没有在celeryconfig.py中配置).我能清楚的看到有哪些事发生，因为你那些可人的后台任务上仅仅有那么一个 装饰器。这里我关心的是，也许 taskA 和 taskB做的是完全不同的两件事情，也许其中一个要比另外一个重要的多，那为什么要把它们扔到一个篮子里呢？虽然一个worker可以处理这两个任务，设想某个时间有大量的taskB，然而更重要的 taskA却没有得到worker的足够重视？这种情况下增加了worker以后，所有的worker还是会平等的对待这两种任务，在大量taskB的情况下，taskA还是无法得到应得的重视。 这就把我们带到了下一个要点中。</p>
<h3 id="NO-3_使用优先级wokers">NO.3 使用优先级wokers</h3><p>解决上面问题办法就是把taskA放到一个队列中去，taskB放到另一个队列中去，分配x个workers去处理Q1队列，有于Q2队列有更多的任务需要处理，其他的workers都分配给Q2队列。这种方式你能保证taskB有足够多的workers去，同时维持几个高优先级的队列给taskA，当taskA任务来的时候不需要等待很久就可以被处理掉。</p>
<p>所以，手工的定义队列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CELERY_QUEUES = (</span><br><span class="line">    Queue(<span class="string">'default'</span>, Exchange(<span class="string">'default'</span>), routing_key=<span class="string">'default'</span>),</span><br><span class="line">    Queue(<span class="string">'for_task_A'</span>, Exchange(<span class="string">'for_task_A'</span>), routing_key=<span class="string">'for_task_A'</span>),</span><br><span class="line">    Queue(<span class="string">'for_task_B'</span>, Exchange(<span class="string">'for_task_B'</span>), routing_key=<span class="string">'for_task_B'</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>你的routes 会决定不同的任务分配到不同的队列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CELERY_ROUTES = &#123;</span><br><span class="line">    <span class="string">'my_taskA'</span>: &#123;<span class="string">'queue'</span>: <span class="string">'for_task_A'</span>, <span class="string">'routing_key'</span>: <span class="string">'for_task_A'</span>&#125;,</span><br><span class="line">    <span class="string">'my_taskB'</span>: &#123;<span class="string">'queue'</span>: <span class="string">'for_task_B'</span>, <span class="string">'routing_key'</span>: <span class="string">'for_task_B'</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后你可以为每个任务启动不同的workers</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">celery worker -E -l INFO -n workerA -Q for_task_A</span><br><span class="line">celery worker -E -l INFO -n workerB -Q for_task_B</span><br></pre></td></tr></table></figure>
<h3 id="No-4_使用Celery’s的错误处理机制">No.4 使用Celery’s的错误处理机制</h3><p>我见过最多就是，任务根本就没有错误处理的概念。如果一个任务失败了就是失败了。在某些情况下这样处理是不错的，然而我见过最多的是一些第三方API的错误，网络原因，或者资源不可用等造成的。最简单的处理这种错误的办法就是对任务进行重试。因为有一些第三方的API是因为服务或者网络的出了问题，但是很快就可以恢复，我们为什么不试一试呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="decorator">@app.task(bind=True, default_retry_delay=300, max_retries=5)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_task_A</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(<span class="string">"doing stuff here..."</span>)</span><br><span class="line">    <span class="keyword">except</span> SomeNetworkException <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">"maybe do some clenup here...."</span>)</span><br><span class="line">        self.retry(e)</span><br></pre></td></tr></table></figure>
<p>我比较喜欢就是给每个任务定义一个重试的间隔和重试的次数(分别是default_retry_delay和max_retries参数)。这是最基本的错误处理方式也是我见过最多的。当然Celery还提供了很多种处理处理但是我把celery的文档地址留给你。</p>
<h3 id="No-5_使用Flower">No.5 使用Flower</h3><p><a href="http://celery.readthedocs.org/en/latest/userguide/monitoring.html#flower-real-time-celery-web-monitor" target="_blank" rel="external">Flower</a> 是一个非常棒的工具，它可以用来监控celery的任务和workers。它是基于web的，所以你可以看到任务进程，详情，worker状态，启动新的workers等。可以通过前面的链接查看它所有的功能。</p>
<h3 id="No-6_只有真正需要才追踪task的结果">No.6 只有真正需要才追踪task的结果</h3><p>task状态指的是task执行的结果是成功还是失败。它对于后续的某些分析是有用的。需要注意的一个问题是退出结果并不是任务执行的结果，那些信息更类似于对数据的某些影响（例如更新用户的朋友列表）</p>
<p>项目中我见过最多的是不关心这些任务执行时候的状态，有些只是用默认的sqlite数据库在保存这些信息，更好一点的是花时间保存在常规的数据库中（例如postgres 或者其他数据库）</p>
<p>为什么无缘无故的增加web应用数据库的负担呢？使用CELERY_IGNORE_RESULT = True配置在你的celeryconfig.py配置文件中来丢弃这些执行状态。</p>
<h3 id="No-7_不要通过数据库或者ORM对象的方式来执行任务">No.7 不要通过数据库或者ORM对象的方式来执行任务</h3><p>在一次本地的Python小聚会上发表这个分享之后有几个人建议我把这一条添加到最佳实践的列表中。这个建议是关于什么的呢？不要通过数据库对象（例如你的User model）来执行后台任务，因为对象序列话是包含了一些陈旧的数据。你要作的是把Userid放在任务中，然后任务执行的时候会从数据中获取最新的用户对象。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p><a href="http://blog.csdn.net/orangleliu" target="_blank" rel="external">orangleliu</a> 翻译  <a href="https://denibertovic.co]]>
    </summary>
    
      <category term="celery" scheme="http://orangleliu.info/tags/celery/"/>
    
      <category term="翻译" scheme="http://orangleliu.info/categories/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
</feed>
